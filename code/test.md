## Evaluation

We would like to evaluate our optimizer in two aspects: theoretical improvement and actual wall-clock speedup.

### Benchmarks

Because loop invariant code motion and strength reduction are specific optimization for loops, and studies are based on case by case, we can hardly generate automatic testing scripts while writing bril codes to generate `for` loop are actually painful. Instead we use Typescript for help. But default Bril scripts generated by Typescript always introduces redundancy during translation, and code motion optimization by default will be performed. We therefore write test cases with no expected optimizations (but will have some when translated to Bril) as baseline to compare actual wall-clock speedup.

| Filename                                | Description                                 |
| --------------------------------------- | ------------------------------------------- |
| `normal.ts`, `nested.ts`, `nestedif.ts` | No optimization expected.                   |
| `codemotion*.ts`                        | Expecting code motion.                      |
| `strengthreduction*.ts`                 | Expecting strength reduction optimizations. |
| `both*.ts`                              | Expecting both kinds of optimizations.      |


### Loop Invariant Code Motion examples

The program `codemotion1.ts` has the following loop code:

```
let a = 8;
let x = 0;
let y = 8;
let z = 1;
let n = 100000;
for (let i = n; i > 0; i = i - 1) {
    x = y + z;
    a = a + x * x;
}
```
Since both `y` and `z` are constants in the loop, computation of `x` in each iteration is redundant and this operation can be moved outside the loop. The optimized Bril code does perform this function outside the loop as:
```
v10: int = id y;
v11: int = id z;
v12: int = add v10 v11;
x: int = id v12; x= y+z
```
and the loop body is reduced to:
```
for.body.5:
v13: int = id a;
v14: int = id x;
v15: int = id x;
v16: int = mul v14 v15; #using the updated x for x*x
v17: int = add v13 v16; #a=a+x*x
a: int = id v17;
```
Assuming the cost of `x=y+z` was `c` we reduced the computation in the program by `(n-1)*c`. To benchmark this, we timed our optimized version using [hyperfine](https://github.com/sharkdp/hyperfine) which helps set warmup times (for warming up the cache) and number of execution runs to perform:
```
hyperfine --warmup 1 'brili < opt_codemotion'

Time (mean ± σ):     163.8 ms ±   3.2 ms
```
The unoptimized version of the code yields:
```
hyperfine --warmup 1 'brili < orig_codemotion'

Time (mean ± σ):     216.8 ms ±   4.5 ms
```
Similarly `codemotion2.ts` has nested loops where invariant code can be moved from inner loops to outer ones. 

```
hyperfine --warmup 1 'brili < orig_codemotion2'
Time (mean ± σ):     216.8 ms ±   4.5 ms

hyperfine --warmup 1 'brili < opt_codemotion1'
Time (mean ± σ):     163.8 ms ±   3.2 ms
```
