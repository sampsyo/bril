## Evaluation

We would like to evaluate our optimizer in two aspects: theoretical improvement and actual wall-clock speedup.

### Benchmarks

Because loop invariant code motion and strength reduction are specific optimization for loops, and studies are based on case by case, we can hardly generate automatic testing scripts while writing bril codes to generate `for` loop are actually painful. Instead we reply on Typescript for help. 

However, default Bril scripts generated by Typescript always introduces redundancy during translation, and code motion optimization by default will be performed. For example, `int v10 = const 5; int v11 = v11 + v10;` can be found in the body of a loop if there is a line `x = x + 5` in Typescript. Because we don't perform other optimizations, we wonder how much speedup is contributed by the redundancy. We therefore write test cases with no expected optimizations (but will have some when translated to Bril) as baseline to compare actual wall-clock speedup.

| Filename                                | Description                                 |
| --------------------------------------- | ------------------------------------------- |
| `normal.ts`, `nested.ts`, `nestedif.ts` | No optimization expected.                   |
| `codemotion*.ts`                        | Expecting code motion.                      |
| `strengthreduction*.ts`                 | Expecting strength reduction optimizations. |
| `both*.ts`                              | Expecting both kinds of optimizations.      |

