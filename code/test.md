## Evaluation

We would like to evaluate our optimizer in two aspects: theoretical improvement and actual wall-clock speedup.

### Benchmarks

Because loop invariant code motion and strength reduction are specific optimization for loops, and studies are based on case by case, we can hardly generate automatic testing scripts while writing bril codes to generate `for` loop are actually painful. Instead we reply on Typescript for help. 

However, default Bril scripts generated by Typescript always introduces redundancy during translation, and code motion optimization by default will be performed. For example, `int v10 = const 5; int v11 = v11 + v10;` can be found in the body of a loop if there is a line `x = x + 5` in Typescript. Because we don't perform other optimizations, we wonder how much speedup is contributed by the redundancy. We therefore write test cases with no expected optimizations (but will have some when translated to Bril) as baseline to compare actual wall-clock speedup.

| Filename                                | Description                                 |
| --------------------------------------- | ------------------------------------------- |
| `normal.ts`, `nested.ts`, `nestedif.ts` | No optimization expected.                   |
| `codemotion*.ts`                        | Expecting code motion.                      |
| `strengthreduction*.ts`                 | Expecting strength reduction optimizations. |
| `both*.ts`                              | Expecting both kinds of optimizations.      |



### Implicit redundancy

Bril scripts generated by Typescript introduce some redundant operations usually an `id` or a `const`. Inside a loop, these would usually be loop invariant code which gets removed by our optimizer. However, we were not sure if this would contribute towards outr speedup. To make sure that these are actually negligible we benchmarked similar codes without explicit loop invariant codes in the loop to see speedups (if any).

We ran `normal.ts` , `nested.ts` and `nestedif.ts` to this end and got the following results:

| Filename       | Unoptimized runtime      | Optimized runtime | 
| -------------- | ---------------------------- | ----------------------|
| `normal.ts` |  193.4 ms | 193.3 ms |
| `nested.ts` |  327.7 ms | 330 ms |
| `nestedif.ts` |  280.4 ms | 276.8 ms |

We observe that these do not change by a large margins and can be ignored.

### Loop Invariant Code Motion examples 

The program `codemotion1.ts` has the following loop code:

```
let a = 8;
let x = 0;
let y = 8;
let z = 1;
let n = 100000;
for (let i = n; i > 0; i = i - 1) {
    x = y + z;
    a = a + x * x;
}
```
Since both `y` and `z` are constants in the loop, computation of `x` in each iteration is redundant and this operation can be moved outside the loop. The optimized Bril code does perform this function outside the loop as:
```
v10: int = id y;
v11: int = id z;
v12: int = add v10 v11;
x: int = id v12; x= y+z
```
and the loop body is reduced to:
```
for.body.5:
v13: int = id a;
v14: int = id x;
v15: int = id x;
v16: int = mul v14 v15; #using the updated x for x*x
v17: int = add v13 v16; #a=a+x*x
a: int = id v17;
```
Assuming the cost of `x=y+z` was `c` we reduced the computation in the program by `(n-1)*c`. To benchmark this, we timed our optimized version using [hyperfine](https://github.com/sharkdp/hyperfine) which helps set warmup times (for warming up the cache) and number of execution runs to perform (10 in our case):
```
hyperfine --warmup 1 'brili < opt_codemotion'

Time (mean ± σ):     163.8 ms ±   3.2 ms
```
The unoptimized version of the code yields:
```
hyperfine --warmup 1 'brili < orig_codemotion'

Time (mean ± σ):     216.8 ms ±   4.5 ms
```
Similarly `codemotion2.ts` has nested loops where invariant code can be moved from inner loops to outer ones. 

```
hyperfine --warmup 1 'brili < orig_codemotion2'
Time (mean ± σ):     908.6 ms ±  14.8 ms

hyperfine --warmup 1 'brili < opt_codemotion2'
Time (mean ± σ):     665.4 ms ±  11.9 ms
```



### Final Results

| Filename       | Unoptimized runtime      | Optimized runtime | Speedup |
| -------------- | ---------------------------- | ----------------------| ---------- |
| `codemotion1.ts` |  216.8 ms | 163.8 ms | 1.32x |
| `codemotion2.ts` |  908.6 ms | 665.4 ms | 1.36x |
