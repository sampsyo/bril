@bit(x: int): int {
  two: int = const 2;
  div2: int = div x two;
  mul2: int = mul div2 two;
  bit: int = sub x mul2;
  ret bit;
}
@bitand(a: int, b: int): int {
  zero: int = const 0;
  one: int = const 1;
  two: int = const 2;
  result: int = const 0;
  pow: int = const 1;
.loop.cond:
  acond: bool = gt a zero;
  bcond: bool = gt b zero;
  cond: bool = or acond bcond;
  br cond .loop.body .loop.end;
.loop.body:
  abit: int = call @bit a;
  bbit: int = call @bit b;
  abit1: bool = eq abit one;
  bbit1: bool = eq bbit one;
  rbitb: bool = and abit1 bbit1;
  rbit: int = const 0;
  br rbitb .setone .skip;
.setone:
  rbit: int = const 1;
.skip:
  term: int = mul rbit pow;
  result: int = add result term;
  a: int = div a two;
  b: int = div b two;
  pow: int = mul pow two;
  jmp .loop.cond;
.loop.end:
  ret result;
}
@bitor(a: int, b: int): int {
  zero: int = const 0;
  one: int = const 1;
  two: int = const 2;
  result: int = const 0;
  pow: int = const 1;
.loop.cond.or:
  acond: bool = gt a zero;
  bcond: bool = gt b zero;
  cond: bool = or acond bcond;
  br cond .loop.body.or .loop.end.or;
.loop.body.or:
  abit: int = call @bit a;
  bbit: int = call @bit b;
  abit1: bool = eq abit one;
  bbit1: bool = eq bbit one;
  rbitb: bool = or abit1 bbit1;
  rbit: int = const 0;
  br rbitb .setone.or .skip.or;
.setone.or:
  rbit: int = const 1;
.skip.or:
  term: int = mul rbit pow;
  result: int = add result term;
  a: int = div a two;
  b: int = div b two;
  pow: int = mul pow two;
  jmp .loop.cond.or;
.loop.end.or:
  ret result;
}
@bitxor(a: int, b: int): int {
  zero: int = const 0;
  one: int = const 1;
  two: int = const 2;
  result: int = const 0;
  pow: int = const 1;
.loop.cond.xor:
  acond: bool = gt a zero;
  bcond: bool = gt b zero;
  cond: bool = or acond bcond;
  br cond .loop.body.xor .loop.end.xor;
.loop.body.xor:
  abit: int = call @bit a;
  bbit: int = call @bit b;
  abit1: bool = eq abit one;
  bbit1: bool = eq bbit one;
  nb: bool = not bbit1;
  na: bool = not abit1;
  t1: bool = and abit1 nb;
  t2: bool = and na bbit1;
  rbitb: bool = or t1 t2;
  rbit: int = const 0;
  br rbitb .setone.xor .skip.xor;
.setone.xor:
  rbit: int = const 1;
.skip.xor:
  term: int = mul rbit pow;
  result: int = add result term;
  a: int = div a two;
  b: int = div b two;
  pow: int = mul pow two;
  jmp .loop.cond.xor;
.loop.end.xor:
  ret result;
}
@ashr(x: int, n: int): int {
  zero: int = const 0;
  one: int = const 1;
  two: int = const 2;
.loop.cond.shr:
  npos: bool = gt n zero;
  br npos .loop.body.shr .loop.end.shr;
.loop.body.shr:
  q: int = div x two;
  q2: int = mul q two;
  r: int = sub x q2;
  neg: bool = lt x zero;
  rzero: bool = eq r zero;
  odd: bool = not rzero;
  fix: bool = and neg odd;
  br fix .adjust .no_adjust;
.adjust:
  q: int = sub q one;
  jmp .after;
.no_adjust:
  jmp .after;
.after:
  x: int = id q;
  n: int = sub n one;
  jmp .loop.cond.shr;
.loop.end.shr:
  ret x;
}
@L.loop.1(prod.1: any, n.2: any): any {
  tmp.26: any = const 8;
  tmp.27: any = call @L.>=.2 n.2 tmp.26;
  tmp.23: any = id tmp.27;
  tmp.29: any = const 6;
  tmp.28: any = eq tmp.23 tmp.29;
  tmp.30: any = not tmp.28;
  br tmp.30 .L.then.5 .L.else.6;
.L.then.5:
  tmp.31: any = call @L.*.3 n.2 prod.1;
  tmp.24: any = id tmp.31;
  tmp.32: any = const 8;
  tmp.33: any = call @L._.4 n.2 tmp.32;
  tmp.25: any = id tmp.33;
  tmp.34: any = call @L.loop.1 tmp.24 tmp.25;
  ret tmp.34;
.L.else.6:
  ret prod.1;
}
@L._.4(tmp.8: any, tmp.9: any): any {
  tmp.35: any = const 7;
  tmp.36: any = call @bitand tmp.9 tmp.35;
  tmp.20: any = id tmp.36;
  tmp.38: any = const 0;
  tmp.37: any = eq tmp.20 tmp.38;
  br tmp.37 .L.then.9 .L.else.10;
.L.then.9:
  tmp.39: any = const 14;
  tmp.19: any = id tmp.39;
  jmp .L.endif.11;
.L.else.10:
  tmp.40: any = const 6;
  tmp.19: any = id tmp.40;
.L.endif.11:
  tmp.42: any = const 6;
  tmp.41: any = eq tmp.19 tmp.42;
  tmp.43: any = not tmp.41;
  br tmp.43 .L.then.7 .L.else.8;
.L.then.7:
  tmp.44: any = const 7;
  tmp.45: any = call @bitand tmp.8 tmp.44;
  tmp.22: any = id tmp.45;
  tmp.47: any = const 0;
  tmp.46: any = eq tmp.22 tmp.47;
  br tmp.46 .L.then.14 .L.else.15;
.L.then.14:
  tmp.48: any = const 14;
  tmp.21: any = id tmp.48;
  jmp .L.endif.16;
.L.else.15:
  tmp.49: any = const 6;
  tmp.21: any = id tmp.49;
.L.endif.16:
  tmp.51: any = const 6;
  tmp.50: any = eq tmp.21 tmp.51;
  tmp.52: any = not tmp.50;
  br tmp.52 .L.then.12 .L.else.13;
.L.then.12:
  tmp.53: any = sub tmp.8 tmp.9;
  ret tmp.53;
.L.else.13:
  tmp.54: any = const 830;
  ret tmp.54;
.L.else.8:
  tmp.55: any = const 830;
  ret tmp.55;
}
@L.*.3(tmp.6: any, tmp.7: any): any {
  tmp.56: any = const 7;
  tmp.57: any = call @bitand tmp.7 tmp.56;
  tmp.15: any = id tmp.57;
  tmp.59: any = const 0;
  tmp.58: any = eq tmp.15 tmp.59;
  br tmp.58 .L.then.19 .L.else.20;
.L.then.19:
  tmp.60: any = const 14;
  tmp.14: any = id tmp.60;
  jmp .L.endif.21;
.L.else.20:
  tmp.61: any = const 6;
  tmp.14: any = id tmp.61;
.L.endif.21:
  tmp.63: any = const 6;
  tmp.62: any = eq tmp.14 tmp.63;
  tmp.64: any = not tmp.62;
  br tmp.64 .L.then.17 .L.else.18;
.L.then.17:
  tmp.65: any = const 7;
  tmp.66: any = call @bitand tmp.6 tmp.65;
  tmp.17: any = id tmp.66;
  tmp.68: any = const 0;
  tmp.67: any = eq tmp.17 tmp.68;
  br tmp.67 .L.then.24 .L.else.25;
.L.then.24:
  tmp.69: any = const 14;
  tmp.16: any = id tmp.69;
  jmp .L.endif.26;
.L.else.25:
  tmp.70: any = const 6;
  tmp.16: any = id tmp.70;
.L.endif.26:
  tmp.72: any = const 6;
  tmp.71: any = eq tmp.16 tmp.72;
  tmp.73: any = not tmp.71;
  br tmp.73 .L.then.22 .L.else.23;
.L.then.22:
  tmp.74: any = const 3;
  tmp.75: any = call @ashr tmp.7 tmp.74;
  tmp.18: any = id tmp.75;
  tmp.76: any = mul tmp.6 tmp.18;
  ret tmp.76;
.L.else.23:
  tmp.77: any = const 318;
  ret tmp.77;
.L.else.18:
  tmp.78: any = const 318;
  ret tmp.78;
}
@L.>=.2(tmp.4: any, tmp.5: any): any {
  tmp.79: any = const 7;
  tmp.80: any = call @bitand tmp.5 tmp.79;
  tmp.11: any = id tmp.80;
  tmp.82: any = const 0;
  tmp.81: any = eq tmp.11 tmp.82;
  br tmp.81 .L.then.29 .L.else.30;
.L.then.29:
  tmp.83: any = const 14;
  tmp.10: any = id tmp.83;
  jmp .L.endif.31;
.L.else.30:
  tmp.84: any = const 6;
  tmp.10: any = id tmp.84;
.L.endif.31:
  tmp.86: any = const 6;
  tmp.85: any = eq tmp.10 tmp.86;
  tmp.87: any = not tmp.85;
  br tmp.87 .L.then.27 .L.else.28;
.L.then.27:
  tmp.88: any = const 7;
  tmp.89: any = call @bitand tmp.4 tmp.88;
  tmp.13: any = id tmp.89;
  tmp.91: any = const 0;
  tmp.90: any = eq tmp.13 tmp.91;
  br tmp.90 .L.then.34 .L.else.35;
.L.then.34:
  tmp.92: any = const 14;
  tmp.12: any = id tmp.92;
  jmp .L.endif.36;
.L.else.35:
  tmp.93: any = const 6;
  tmp.12: any = id tmp.93;
.L.endif.36:
  tmp.95: any = const 6;
  tmp.94: any = eq tmp.12 tmp.95;
  tmp.96: any = not tmp.94;
  br tmp.96 .L.then.32 .L.else.33;
.L.then.32:
  tmp.97: any = ge tmp.4 tmp.5;
  br tmp.97 .L.then.37 .L.else.38;
.L.then.37:
  tmp.98: any = const 14;
  ret tmp.98;
.L.else.38:
  tmp.99: any = const 6;
  ret tmp.99;
.L.else.33:
  tmp.100: any = const 1854;
  ret tmp.100;
.L.else.28:
  tmp.101: any = const 1854;
  ret tmp.101;
}
@main: any {
  tmp.102: any = const 64;
  arg.x.3: any = id tmp.102;
  tmp.103: any = const 8;
  tmp.104: any = call @L.loop.1 tmp.103 arg.x.3;
  tmp.105: any = const 8;
  tmp.104: any = div tmp.104 tmp.105;
  print tmp.104;
}
