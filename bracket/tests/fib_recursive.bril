@bit(x: int): int {
  two: int = const 2;
  div2: int = div x two;
  mul2: int = mul div2 two;
  bit: int = sub x mul2;
  ret bit;
}
@bitand(a: int, b: int): int {
  zero: int = const 0;
  one: int = const 1;
  two: int = const 2;
  result: int = const 0;
  pow: int = const 1;
.loop.cond:
  acond: bool = gt a zero;
  bcond: bool = gt b zero;
  cond: bool = or acond bcond;
  br cond .loop.body .loop.end;
.loop.body:
  abit: int = call @bit a;
  bbit: int = call @bit b;
  abit1: bool = eq abit one;
  bbit1: bool = eq bbit one;
  rbitb: bool = and abit1 bbit1;
  rbit: int = const 0;
  br rbitb .setone .skip;
.setone:
  rbit: int = const 1;
.skip:
  term: int = mul rbit pow;
  result: int = add result term;
  a: int = div a two;
  b: int = div b two;
  pow: int = mul pow two;
  jmp .loop.cond;
.loop.end:
  ret result;
}
@bitor(a: int, b: int): int {
  zero: int = const 0;
  one: int = const 1;
  two: int = const 2;
  result: int = const 0;
  pow: int = const 1;
.loop.cond.or:
  acond: bool = gt a zero;
  bcond: bool = gt b zero;
  cond: bool = or acond bcond;
  br cond .loop.body.or .loop.end.or;
.loop.body.or:
  abit: int = call @bit a;
  bbit: int = call @bit b;
  abit1: bool = eq abit one;
  bbit1: bool = eq bbit one;
  rbitb: bool = or abit1 bbit1;
  rbit: int = const 0;
  br rbitb .setone.or .skip.or;
.setone.or:
  rbit: int = const 1;
.skip.or:
  term: int = mul rbit pow;
  result: int = add result term;
  a: int = div a two;
  b: int = div b two;
  pow: int = mul pow two;
  jmp .loop.cond.or;
.loop.end.or:
  ret result;
}
@bitxor(a: int, b: int): int {
  zero: int = const 0;
  one: int = const 1;
  two: int = const 2;
  result: int = const 0;
  pow: int = const 1;
.loop.cond.xor:
  acond: bool = gt a zero;
  bcond: bool = gt b zero;
  cond: bool = or acond bcond;
  br cond .loop.body.xor .loop.end.xor;
.loop.body.xor:
  abit: int = call @bit a;
  bbit: int = call @bit b;
  abit1: bool = eq abit one;
  bbit1: bool = eq bbit one;
  nb: bool = not bbit1;
  na: bool = not abit1;
  t1: bool = and abit1 nb;
  t2: bool = and na bbit1;
  rbitb: bool = or t1 t2;
  rbit: int = const 0;
  br rbitb .setone.xor .skip.xor;
.setone.xor:
  rbit: int = const 1;
.skip.xor:
  term: int = mul rbit pow;
  result: int = add result term;
  a: int = div a two;
  b: int = div b two;
  pow: int = mul pow two;
  jmp .loop.cond.xor;
.loop.end.xor:
  ret result;
}
@ashr(x: int, n: int): int {
  zero: int = const 0;
  one: int = const 1;
  two: int = const 2;
.loop.cond.shr:
  npos: bool = gt n zero;
  br npos .loop.body.shr .loop.end.shr;
.loop.body.shr:
  q: int = div x two;
  q2: int = mul q two;
  r: int = sub x q2;
  neg: bool = lt x zero;
  rzero: bool = eq r zero;
  odd: bool = not rzero;
  fix: bool = and neg odd;
  br fix .adjust .no_adjust;
.adjust:
  q: int = sub q one;
  jmp .after;
.no_adjust:
  jmp .after;
.after:
  x: int = id q;
  n: int = sub n one;
  jmp .loop.cond.shr;
.loop.end.shr:
  ret x;
}
@L.fibo.1(n.1: any): any {
  tmp.26: any = const 8;
  tmp.27: any = call @L.<=.2 n.1 tmp.26;
  tmp.21: any = id tmp.27;
  tmp.29: any = const 6;
  tmp.28: any = eq tmp.21 tmp.29;
  tmp.30: any = not tmp.28;
  br tmp.30 .L.then.5 .L.else.6;
.L.then.5:
  ret n.1;
.L.else.6:
  tmp.31: any = const 8;
  tmp.32: any = call @L._.4 n.1 tmp.31;
  tmp.23: any = id tmp.32;
  tmp.33: any = call @L.fibo.1 tmp.23;
  tmp.22: any = id tmp.33;
  tmp.34: any = const 16;
  tmp.35: any = call @L._.4 n.1 tmp.34;
  tmp.25: any = id tmp.35;
  tmp.36: any = call @L.fibo.1 tmp.25;
  tmp.24: any = id tmp.36;
  tmp.37: any = call @L.+.3 tmp.22 tmp.24;
  ret tmp.37;
}
@L._.4(tmp.7: any, tmp.8: any): any {
  tmp.38: any = const 7;
  tmp.39: any = call @bitand tmp.8 tmp.38;
  tmp.18: any = id tmp.39;
  tmp.41: any = const 0;
  tmp.40: any = eq tmp.18 tmp.41;
  br tmp.40 .L.then.9 .L.else.10;
.L.then.9:
  tmp.42: any = const 14;
  tmp.17: any = id tmp.42;
  jmp .L.endif.11;
.L.else.10:
  tmp.43: any = const 6;
  tmp.17: any = id tmp.43;
.L.endif.11:
  tmp.45: any = const 6;
  tmp.44: any = eq tmp.17 tmp.45;
  tmp.46: any = not tmp.44;
  br tmp.46 .L.then.7 .L.else.8;
.L.then.7:
  tmp.47: any = const 7;
  tmp.48: any = call @bitand tmp.7 tmp.47;
  tmp.20: any = id tmp.48;
  tmp.50: any = const 0;
  tmp.49: any = eq tmp.20 tmp.50;
  br tmp.49 .L.then.14 .L.else.15;
.L.then.14:
  tmp.51: any = const 14;
  tmp.19: any = id tmp.51;
  jmp .L.endif.16;
.L.else.15:
  tmp.52: any = const 6;
  tmp.19: any = id tmp.52;
.L.endif.16:
  tmp.54: any = const 6;
  tmp.53: any = eq tmp.19 tmp.54;
  tmp.55: any = not tmp.53;
  br tmp.55 .L.then.12 .L.else.13;
.L.then.12:
  tmp.56: any = sub tmp.7 tmp.8;
  ret tmp.56;
.L.else.13:
  tmp.57: any = const 830;
  ret tmp.57;
.L.else.8:
  tmp.58: any = const 830;
  ret tmp.58;
}
@L.+.3(tmp.5: any, tmp.6: any): any {
  tmp.59: any = const 7;
  tmp.60: any = call @bitand tmp.6 tmp.59;
  tmp.14: any = id tmp.60;
  tmp.62: any = const 0;
  tmp.61: any = eq tmp.14 tmp.62;
  br tmp.61 .L.then.19 .L.else.20;
.L.then.19:
  tmp.63: any = const 14;
  tmp.13: any = id tmp.63;
  jmp .L.endif.21;
.L.else.20:
  tmp.64: any = const 6;
  tmp.13: any = id tmp.64;
.L.endif.21:
  tmp.66: any = const 6;
  tmp.65: any = eq tmp.13 tmp.66;
  tmp.67: any = not tmp.65;
  br tmp.67 .L.then.17 .L.else.18;
.L.then.17:
  tmp.68: any = const 7;
  tmp.69: any = call @bitand tmp.5 tmp.68;
  tmp.16: any = id tmp.69;
  tmp.71: any = const 0;
  tmp.70: any = eq tmp.16 tmp.71;
  br tmp.70 .L.then.24 .L.else.25;
.L.then.24:
  tmp.72: any = const 14;
  tmp.15: any = id tmp.72;
  jmp .L.endif.26;
.L.else.25:
  tmp.73: any = const 6;
  tmp.15: any = id tmp.73;
.L.endif.26:
  tmp.75: any = const 6;
  tmp.74: any = eq tmp.15 tmp.75;
  tmp.76: any = not tmp.74;
  br tmp.76 .L.then.22 .L.else.23;
.L.then.22:
  tmp.77: any = add tmp.5 tmp.6;
  ret tmp.77;
.L.else.23:
  tmp.78: any = const 574;
  ret tmp.78;
.L.else.18:
  tmp.79: any = const 574;
  ret tmp.79;
}
@L.<=.2(tmp.3: any, tmp.4: any): any {
  tmp.80: any = const 7;
  tmp.81: any = call @bitand tmp.4 tmp.80;
  tmp.10: any = id tmp.81;
  tmp.83: any = const 0;
  tmp.82: any = eq tmp.10 tmp.83;
  br tmp.82 .L.then.29 .L.else.30;
.L.then.29:
  tmp.84: any = const 14;
  tmp.9: any = id tmp.84;
  jmp .L.endif.31;
.L.else.30:
  tmp.85: any = const 6;
  tmp.9: any = id tmp.85;
.L.endif.31:
  tmp.87: any = const 6;
  tmp.86: any = eq tmp.9 tmp.87;
  tmp.88: any = not tmp.86;
  br tmp.88 .L.then.27 .L.else.28;
.L.then.27:
  tmp.89: any = const 7;
  tmp.90: any = call @bitand tmp.3 tmp.89;
  tmp.12: any = id tmp.90;
  tmp.92: any = const 0;
  tmp.91: any = eq tmp.12 tmp.92;
  br tmp.91 .L.then.34 .L.else.35;
.L.then.34:
  tmp.93: any = const 14;
  tmp.11: any = id tmp.93;
  jmp .L.endif.36;
.L.else.35:
  tmp.94: any = const 6;
  tmp.11: any = id tmp.94;
.L.endif.36:
  tmp.96: any = const 6;
  tmp.95: any = eq tmp.11 tmp.96;
  tmp.97: any = not tmp.95;
  br tmp.97 .L.then.32 .L.else.33;
.L.then.32:
  tmp.98: any = le tmp.3 tmp.4;
  br tmp.98 .L.then.37 .L.else.38;
.L.then.37:
  tmp.99: any = const 14;
  ret tmp.99;
.L.else.38:
  tmp.100: any = const 6;
  ret tmp.100;
.L.else.33:
  tmp.101: any = const 1342;
  ret tmp.101;
.L.else.28:
  tmp.102: any = const 1342;
  ret tmp.102;
}
@main: any {
  tmp.103: any = const 80;
  arg.x.2: any = id tmp.103;
  tmp.104: any = call @L.fibo.1 arg.x.2;
  tmp.105: any = const 8;
  tmp.104: any = div tmp.104 tmp.105;
  print tmp.104;
}
